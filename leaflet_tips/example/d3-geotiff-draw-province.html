<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        html,body{
            margin: 0;
            padding:0 ;
        }
        #container{
            height: 600px;
            width: 600px;
            margin: 50px auto;
            border: 2px solid #000;
        }
    </style>
</head>
<body>
<select id="select"></select>
<div id="container">

</div>


<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="../lib/geotiff.bundle.min.1.0.0@beta6.js"></script>
<script src="../lib/chroma.min.js"></script>
<script>
    const [width,height] = [600,600]
    var canvas = d3.select('#container').append("canvas")
        .attr("width", width)
        .attr("height", height);

    var context = canvas.node().getContext("2d");
    context.save();
    context.globalAlpha = "0.9";
    let  geometry,obj = {},geoTransform,tempData,imgH,imgW;

    d3.json('../data/china.json').then((d)=> {
        geometry= d

        obj.crs = d.crs
        obj.type = d.type


        const select = document.getElementById('select')
        d.features.forEach(item => {
            const op = new Option(item.properties.name, item.properties.id)
            select.options[select.length] = (op)
        })

        d3.buffer("../data/pressure.tif").then(function (tiffData,err) {
            console.log(tiffData);


            (async function (){

                const tiff = await GeoTIFF.fromArrayBuffer(tiffData)
                const image = await tiff.getImage();
                const data = await image.readRasters();
                const tiepoint = image.getTiePoints()[0];
                const pixelScale = image.getFileDirectory().ModelPixelScale;
                console.log(image,tiepoint)
                imgW = image.getWidth()
                imgH = image.getHeight()

                geoTransform = [tiepoint.x, pixelScale[0], 0, tiepoint.y, 0, -1 * pixelScale[1]];

                tempData = new Array(imgH);
                for (var j = 0; j<imgH; j++){
                    tempData[j] = new Array(imgW);
                    for (var i = 0; i<image.getWidth(); i++){
                        tempData[j][i] = data[0][i + j*imgW];
                    }
                }

                select.onchange = function () {
                    const id = this.value
                    console.log(id)
                    drawPath(id)
                }
            })();

        })
    }).catch(e => console.log(e))

    function drawPath(id) {
        context.restore();
        const imgdata = context.createImageData(width, height);
        context.clearRect(0, 0, width, height)

        const f = geometry.features.filter(f => f.properties.id == id)

        obj.features = f

        const bound = d3.geoBounds(obj)

        let t0 = Date.now()
        var projection = d3.geoMercator()
        projection.fitExtent([[0, 0], [width, height]], obj)
        let pos = 0;
        for (var j = 0; j < height; j += 1) {
            for (var i = 0; i < width; i += 1) {
                var pointCoords = projection.invert([i, j]);
                var px = (pointCoords[0] - geoTransform[0]) / geoTransform[1]

                var py = (pointCoords[1] - geoTransform[3]) / geoTransform[5]

                if (Math.floor(px) >= 0 && Math.ceil(px) < imgW && Math.floor(py) >= 0 && Math.ceil(py) < imgH
                //&& d3.geoContains(obj,pointCoords
                ) {
                    var value = interpolatedValueAtIndexes(px, py);
                    //if (value > 0){

                    //context.fillStyle = getColor(value);
                    let [R, G, B, A] = getColor(value);
                    imgdata.data[pos] = R;
                    imgdata.data[pos + 1] = G;
                    imgdata.data[pos + 2] = B;
                    imgdata.data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255
                    //context.fillRect(i , j ,2, 2);
                    //}
                    pos += 4
                }
            }
        }

        context.putImageData(imgdata, 0, 0)

        var path = d3.geoPath()
            .projection(projection).context(context);



        //ctx.beginPath();
        context.globalCompositeOperation = 'destination-atop'
        //'destination-out';
        context.strokeStyle = "#000";
        context.fillStyle = "rgba(255,0,0,1)";
        path(obj);

        context.fill();
        //context.stroke();
        //getAImage(obj)
        let t1 = Date.now()
        console.log(t1 - t0)

    }

    function getAImage(obj){
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = width;
        canvas.height = height;
        var projection = d3.geoMercator()
        projection.fitExtent([[0, 0], [width, height]], obj)
        var path = d3.geoPath()
            .projection(projection).context(ctx);


        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fillRect(0,0,width,height)
        //ctx.beginPath();
        ctx.globalCompositeOperation = 'xor'
        //'destination-out';
        ctx.strokeStyle = "#000";
        ctx.fillStyle = "rgba(255,0,0,1)";
        path(obj);

        ctx.fill();
        ctx.stroke();

        const image = document.getElementById('img') || new Image();
        image.src = canvas.toDataURL();
        image.className ='img'
        image.id ='img'
        document.getElementById('container').appendChild(image)
        //console.log(image)
        //return image;
    }

    const d = 1/(110000 - 90000)
    const scale =  chroma.scale(["#0000ff", "#00fff7", "#00ff08", "#ffff00", "#ff0000"])
        .domain([80000,85000,95000,100000,101000,101500,102000,102500,103000,103500])
    //.domain([60000,110000])
    function getColor(v){
        return scale(v).rgba()

    }

    function interpolatedValueAtIndexes(i,j){
        const raster = tempData
        let tiff_width = imgW
        let tiff_height = imgH
        let fi,fj,ci,cj
        let g00, g10, g01, g11
        if(i >= tiff_width - 1){
            fi = ci =  tiff_width - 1
        }else{
            fi = Math.floor(i)
            ci = fi + 1
        }
        if(j >= tiff_height - 1){
            fj = cj =  tiff_height - 1
        }else{
            fj = Math.floor(j)
            cj = fj + 1
        }
        const row0 = raster[fj]
        g00 = row0[fi]
        g10 = row0[ci];

        const row1 = raster[cj]

        g01 = row1[fi]
        g11 = row1[ci];
        return this._doInterpolation(i-fi,j-fj,g00, g10, g01, g11)
    }
    /**
     * Bilinear interpolation for Number
     */
    function  _doInterpolation(x, y, g00, g10, g01, g11) {
        const  rx = 1 - x;
        const  ry = 1 - y;
        //debugger;
        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;
    }
</script>
</body>
</html>